app.py
requirements.txt
manual_tecnico/   (aqu√≠ luego pondr√°s tu manual en PDF)

streamlit
pandas
openpyxl
plotly
openai

import os
import pandas as pd
import streamlit as st
import plotly.express as px

# =============== CONFIG ===============
st.set_page_config(page_title="Dashboard Ventas vs Presupuesto (KG)", layout="wide")

MESES_ORDEN = [
    "Enero","Febrero","Marzo","Abril","Mayo","Junio",
    "Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"
]

# Ajustado a tu "Reporte de ventas" (QTZ + KG por mes)
MESES_VENTAS = {
    "Enero": ("Enero_QTZ", "Ene_KG"),
    "Febrero": ("Febrero_QTZ", "Feb_KG"),
    "Marzo": ("Marzo_QTZ", "Mar_KG"),
    "Abril": ("Abril_QTZ", "Abr_KG"),
    "Mayo": ("Mayo_QTZ", "May_KG"),
    "Junio": ("Junio_QTZ", "Jun_KG"),
    "Julio": ("Julio_QTZ", "Jul_KG"),
    "Agosto": ("Agosto_QTZ", "Ago_KG"),
    "Septiembre": ("Septiembre_QTZ", "Sep_KG"),
    "Octubre": ("Octubre_QTZ", "Oct_KG"),
    "Noviembre": ("Noviembre_QTZ", "Nov_KG"),
    "Diciembre": ("Diciembre_QTZ", "Dic_KG"),
}

# Ajustado a tu "Presupuesto de ventas" (ENE..DIC en KG)
MESES_PRES = {
    "Enero": "ENE", "Febrero": "FEB", "Marzo": "MAR", "Abril": "ABR",
    "Mayo": "MAY", "Junio": "JUN", "Julio": "JUL", "Agosto": "AGO",
    "Septiembre": "SEP", "Octubre": "OCT", "Noviembre": "NOV", "Diciembre": "DIC",
}

# =============== HELPERS ===============
def _num(s: pd.Series) -> pd.Series:
    return pd.to_numeric(s, errors="coerce").fillna(0)

def normalizar_ventas(df: pd.DataFrame, anio: int) -> pd.DataFrame:
    # Columnas base esperadas (ajusta si tu archivo cambia)
    id_cols = ["SlpName", "C√≥digo de cliente/proveedor", "ItemCode", "ItemName"]
    faltan = [c for c in id_cols if c not in df.columns]
    if faltan:
        raise ValueError(f"Faltan columnas en Ventas: {faltan}")

    out = []
    for mes, (_col_qtz, col_kg) in MESES_VENTAS.items():
        if col_kg not in df.columns:
            raise ValueError(f"Falta la columna '{col_kg}' en Ventas.")
        tmp = df[id_cols].copy()
        tmp["anio"] = anio
        tmp["mes"] = mes
        tmp["actual_kg"] = _num(df[col_kg])
        out.append(tmp)

    long = pd.concat(out, ignore_index=True)
    long["mes"] = pd.Categorical(long["mes"], categories=MESES_ORDEN, ordered=True)
    return long

def normalizar_presupuesto(df: pd.DataFrame, anio: int) -> pd.DataFrame:
    id_cols = ["Nombre de cliente", "Clasificaci√≥n", "ItemCode", "Nombre SKU", "PA√çS"]
    faltan = [c for c in id_cols if c not in df.columns]
    if faltan:
        raise ValueError(f"Faltan columnas en Presupuesto: {faltan}")

    out = []
    for mes, col_kg in MESES_PRES.items():
        if col_kg not in df.columns:
            raise ValueError(f"Falta la columna '{col_kg}' en Presupuesto.")
        tmp = df[id_cols].copy()
        tmp["anio"] = anio
        tmp["mes"] = mes
        tmp["budget_kg"] = _num(df[col_kg])
        out.append(tmp)

    long = pd.concat(out, ignore_index=True)
    long["mes"] = pd.Categorical(long["mes"], categories=MESES_ORDEN, ordered=True)
    return long

def calcular_cumplimiento(ventas_long: pd.DataFrame, pres_long: pd.DataFrame) -> pd.DataFrame:
    # Uni√≥n principal por anio+mes+ItemCode (robusta sin depender de nombre/c√≥digo cliente)
    merged = ventas_long.merge(
        pres_long,
        on=["anio", "mes", "ItemCode"],
        how="left",
        suffixes=("_act", "_bud")
    )

    merged["budget_kg"] = merged["budget_kg"].fillna(0)
    merged["var_kg"] = merged["actual_kg"] - merged["budget_kg"]
    merged["cumpl_pct"] = (merged["actual_kg"] / merged["budget_kg"]).replace([float("inf")], 0).fillna(0) * 100
    return merged

def kpis(df: pd.DataFrame) -> dict:
    actual = float(df["actual_kg"].sum())
    budget = float(df["budget_kg"].sum())
    var = actual - budget
    cumpl = (actual / budget * 100) if budget > 0 else 0.0
    return {"actual": actual, "budget": budget, "var": var, "cumpl": cumpl}

# =============== UI ===============
st.title("üìä Dashboard Gerencial ‚Äî Cumplimiento vs Presupuesto (KG)")
tab1, tab2, tab3 = st.tabs(["1) Cargar Excel", "2) Dashboard (KG)", "3) Asistente IA T√©cnico"])

# -------- TAB 1: CARGA --------
with tab1:
    st.subheader("Carga mensual de data (Excel)")
    colA, colB = st.columns(2)

    with colA:
        anio_ventas = st.number_input("A√±o Ventas", min_value=2020, max_value=2035, value=2026, step=1)
        ventas_file = st.file_uploader("Sube tu 'Reporte de ventas' (.xlsx)", type=["xlsx"], key="ventas")

    with colB:
        anio_pres = st.number_input("A√±o Presupuesto", min_value=2020, max_value=2035, value=2026, step=1)
        pres_file = st.file_uploader("Sube tu 'Presupuesto de ventas' (.xlsx)", type=["xlsx"], key="pres")

    st.info("Tip: si tu Excel tiene varias hojas, aseg√∫rate de que la primera hoja sea la tabla principal, o ajusta el nombre de hoja en el c√≥digo.")

    if st.button("Procesar archivos"):
        if ventas_file is None or pres_file is None:
            st.error("Sube ambos archivos: Ventas y Presupuesto.")
        else:
            try:
                df_ventas = pd.read_excel(ventas_file)
                df_pres = pd.read_excel(pres_file)

                ventas_long = normalizar_ventas(df_ventas, int(anio_ventas))
                pres_long = normalizar_presupuesto(df_pres, int(anio_pres))

                df_final = calcular_cumplimiento(ventas_long, pres_long)

                st.session_state["ventas_long"] = ventas_long
                st.session_state["pres_long"] = pres_long
                st.session_state["df_final"] = df_final

                st.success("‚úÖ Archivos procesados. Ve a la pesta√±a 'Dashboard (KG)'.")
                st.write("Muestra (ventas normalizadas):")
                st.dataframe(ventas_long.head(10))
                st.write("Muestra (presupuesto normalizado):")
                st.dataframe(pres_long.head(10))

            except Exception as e:
                st.exception(e)

# -------- TAB 2: DASHBOARD --------
with tab2:
    st.subheader("Cumplimiento vs Presupuesto (KG)")

    if "df_final" not in st.session_state:
        st.warning("Primero carga y procesa tus Excel en la pesta√±a 1.")
    else:
        df = st.session_state["df_final"].copy()

        # Filtros
        st.sidebar.header("Filtros")
        anio = st.sidebar.selectbox("A√±o", sorted(df["anio"].unique()))
        df = df[df["anio"] == anio]

        mes_sel = st.sidebar.multiselect("Mes", MESES_ORDEN, default=MESES_ORDEN)
        if mes_sel:
            df = df[df["mes"].isin(mes_sel)]

        vendedores = sorted(df["SlpName"].dropna().unique())
        vend_sel = st.sidebar.multiselect("Vendedor", vendedores, default=vendedores)
        if vend_sel:
            df = df[df["SlpName"].isin(vend_sel)]

        skus = sorted(df["ItemCode"].dropna().unique())
        sku_sel = st.sidebar.multiselect("SKU (ItemCode)", skus, default=skus[: min(50, len(skus))])
        if sku_sel:
            df = df[df["ItemCode"].isin(sku_sel)]

        # KPIs
        m = kpis(df)
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Actual (KG)", f"{m['actual']:,.0f}")
        c2.metric("Budget (KG)", f"{m['budget']:,.0f}")
        c3.metric("Varianza (KG)", f"{m['var']:,.0f}")
        c4.metric("% Cumplimiento", f"{m['cumpl']:.1f}%")

        # Tendencia mensual
        st.markdown("### Tendencia mensual (Actual vs Budget)")
        by_mes = (
            df.groupby("mes", as_index=False)[["actual_kg", "budget_kg"]]
              .sum()
              .sort_values("mes")
        )
        fig = px.line(by_mes, x="mes", y=["actual_kg", "budget_kg"], markers=True)
        st.plotly_chart(fig, use_container_width=True)

        # Cumplimiento por vendedor
        st.markdown("### Cumplimiento por vendedor (KG)")
        by_vend = df.groupby("SlpName", as_index=False)[["actual_kg","budget_kg"]].sum()
        by_vend["cumpl_pct"] = by_vend.apply(lambda r: (r["actual_kg"]/r["budget_kg"]*100) if r["budget_kg"]>0 else 0, axis=1)
        by_vend = by_vend.sort_values("cumpl_pct", ascending=False)
        fig2 = px.bar(by_vend, x="SlpName", y="cumpl_pct")
        st.plotly_chart(fig2, use_container_width=True)

        # Top SKUs por varianza
        st.markdown("### Top SKUs por varianza (KG)")
        by_sku = df.groupby(["ItemCode","ItemName"], as_index=False)[["actual_kg","budget_kg","var_kg"]].sum()
        by_sku = by_sku.sort_values("var_kg", ascending=True)  # negativos primero
        st.dataframe(by_sku.head(20))

# -------- TAB 3: ASISTENTE IA --------
with tab3:
    st.subheader("Asistente IA t√©cnico (basado en tu manual)")
    st.caption("Objetivo: recomendar especificaciones de bolsa/bobina usando tu manual interno. Si no hay evidencia, debe pedir datos faltantes.")

    st.markdown("""
**C√≥mo lo usar√°s:**
1) Subes el manual t√©cnico en PDF a tu repositorio (carpeta `manual_tecnico/`) o a un Vector Store de OpenAI.  
2) El asistente responde citando el manual (no inventa).  
""")

    st.info("Este chat queda listo, pero para que funcione necesitas configurar tu OPENAI_API_KEY en secretos y crear un Vector Store con tu manual.")

    # UI de chat
    if "chat" not in st.session_state:
        st.session_state["chat"] = []

    for msg in st.session_state["chat"]:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])

    user_q = st.chat_input("Pregunta t√©cnica (ej: bolsa para caf√© 500g, ¬øqu√© barrera y calibre sugieres?)")

    if user_q:
        st.session_state["chat"].append({"role": "user", "content": user_q})
        with st.chat_message("user"):
            st.markdown(user_q)

        # Respuesta (placeholder / plantilla)
        with st.chat_message("assistant"):
            # Si hay API Key, intentamos llamar a OpenAI (RAG)
            api_key = None
            try:
                api_key = st.secrets.get("OPENAI_API_KEY", None)
            except Exception:
                api_key = os.environ.get("OPENAI_API_KEY")

            if not api_key:
                st.markdown(
                    "Para activar la IA: agrega `OPENAI_API_KEY` en Secrets (Streamlit Cloud) "
                    "y configura un Vector Store con tu manual."
                )
            else:
                # Implementaci√≥n m√≠nima (requiere que t√∫ hayas creado un vector_store_id)
                vector_store_id = None
                try:
                    vector_store_id = st.secrets.get("OPENAI_VECTOR_STORE_ID", None)
                except Exception:
                    vector_store_id = os.environ.get("OPENAI_VECTOR_STORE_ID")

                if not vector_store_id:
                    st.markdown("Falta `OPENAI_VECTOR_STORE_ID` en Secrets. Crea un Vector Store y pon su ID aqu√≠.")
                else:
                    try:
                        from openai import OpenAI
                        client = OpenAI(api_key=api_key)

                        system_instructions = """
Eres un asistente t√©cnico para empaque pl√°stico flexible.
Reglas:
- Responde SOLO usando informaci√≥n encontrada en el manual (file search).
- Si no hay evidencia suficiente, NO inventes: pide los datos faltantes (producto, m√°quina, ancho, calibre, barrera OTR/WVTR, tipo de sello, etc.).
- Da respuesta en formato: Recomendaci√≥n / Supuestos y datos faltantes / Fuente (manual).
"""

                        resp = client.responses.create(
                            model="gpt-5",
                            input=[
                                {"role": "system", "content": system_instructions},
                                {"role": "user", "content": user_q},
                            ],
                            tools=[{
                                "type": "file_search",
                                "vector_store_ids": [vector_store_id]
                            }],
                        )

                        answer = resp.output_text
                        st.markdown(answer)
                        st.session_state["chat"].append({"role": "assistant", "content": answer})

                    except Exception as e:
                        st.error("Error llamando a OpenAI. Revisa API key, vector store y permisos.")
                        st.exception(e)

vector_store_id

